# Android Binder 机制

## 核心概念

### 进程空间的划分

`Android` 系统的核心是 `Linux 内核`。相对于普通的应用程序，`Linux 内核`可以访问受保护的内存空间，也可以访问底层硬件。

为了确保 `Linux 内核`的安全，`Android` 系统将内存空间划分为两部分，`用户空间`和`内核空间`，它们的区别如下：

* `Android` 的应用程序运行在`用户空间`，应用程序之间是相互隔离的，也就是说，`用户空间`中的数据不可以直接访问
* `Android` 系统中每个进程都可以通过系统调用进入`内核空间`，也就是说，`Android` 系统中的所有进程共享`内核空间`，它们之间可以彼此交换数据

在同一进程中，`用户空间`和`内核空间`之间通过如下函数进行数据交互：

* `copy_from_user()`：将 `用户空间`的数据拷贝到`内核空间`
* `copy_to_user()`：将`内核空间`的数据拷贝到`用户空间`

`用户空间`和`内核空间`的相互关系如下图所示：

![](https://upload-images.jianshu.io/upload_images/944365-13d59058d4e0cba1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 进程隔离和进程间通信（IPC）

`进程隔离`是为了保证操作系统中的进程互不干扰而设计的一种保护机制。一个进程不能直接操作或者访问另一个进程的数据，这也就是说，`Android` 系统中的进程是相互独立且隔离的。

`进程间通信（Inter-Process Communication，IPC）`是提供一种进程间数据交互的方案。每个进程都运行在各自独立的`用户空间`中，进程与进程之间相互独立，彼此隔离。所以进程之间交换数据必须依靠内核：
 
* 在内核中开辟一块缓冲区
* `进程 A` 把数据从`进程 A` 的`用户空间`拷贝到缓冲区
* `进程 B` 从缓冲区读取`进程 A` 写入的数据，拷贝到`进程 B` 的用户空间中

`Linux` 内核提供的这种机制称之为进程间通信机制（`Inter-Process Communication，IPC`）。
 

目前，`Linux` 内核常用的 `IPC` 方式有如下七种：
 
* 匿名管道（`Pine`）：管道的本质是一个内存的缓冲区，具有以下特点：
    * 管道只能工作在半双工状态，也就是说，管道中的数据只能向一个方向流动。双方通信时，需要通信双方建立两个管道
    * 管道只能用于具有亲缘关系的进程间通信（父子进程或兄弟进程之间，因为管道没有名称）
    * 管道所传输的是无格式字节流，这也就意味着管道的通信双方需要事先约定好数据协议
    * 管道没有名称，而且其缓冲区大小是有限的
    
* 有名管道：有名管道不同于匿名管道之处在于，有名管道提供了一个路径名与之关联，以有名管道的文件形式存于文件系统中。这样一来，即使与有名管道的创建进程不存在亲缘关系的进程，只要可以该访问文件路径，就能够通过有名管道进行通信。

> 管道是一种特殊类型的文件，在满足先进先出的原则的前提下可以进行读写操作，但是不能进行定位读写。
> 匿名管道在创建时直接返回文件描述符，无需显式的打开。在读写时需要确定对方进程的存在，否则将会退出。也就是说，如果当前进程向匿名管道的一端写入数据，必须确定管道另一端有一个进程在读取数据。如果写入匿名管道的数据量超过其最大值，写操作将会阻塞。同样的，如果管道中没有数据，读操作将会阻塞。
> 有名管道在打开时必须确认双方的存在，否则将会阻塞。
> 关于管道的 `C 语言`实现，请参考 [进程间通信--管道的 C 语言实现](http://blog.chinaunix.net/uid-26833883-id-3227144.html)。

* 信号（Signal）信号具有如下特点：
    * 信号可以在任何时候发送给其他进程，而无需关心接收该信号的进程的状态
    * 如果接收信号的进程当前并未处于执行状态，`Linux 内核`会将该信号保存起来，直到该进程恢复执行并将信号传递给该进程
    * 如果一个信号被进程设置为阻塞状态，那么该信号的传递将会被延迟，直到其阻塞状态被取消时才会传递该信号

> `Linux 内核`中常用的信号有如下几种：
> * SIGHUP：用户从终端注销，所有已启动进程都将收到该进程；
> * SIGINT：程序终止信号；
> * SIGQUIT：程序退出信号；
> * SIGBUS 和 SIGSEGV：进程访问非法地址；
> * SIGFPE：运算中出现致命错误，如除零操作、数据溢出等；
> * SIGKILL：用户终止进程执行信号；
> * SIGTERM：结束进程信号；
> * SIGALRM：定时器信号；
> * SIGCLD：子进程退出信号。

* 消息队列：消息队列是存放在 `Linux 内核`中的消息链表，每个消息队列由消息队列标识符表示。消息队列有如下特点：
    * 消息队列允许一个或多个进程向它写入/读取消息
    * 消息队列的通信数据都是基于先进先出的原则
    * 消息队列可以实现消息的随机查询，消息可以按照消息的类型读取，不一定按照先进先出的次序读取
    * 相比于信号，消息队列承载的信号量更多
    * 相比于管道，消息队列可以承载有格式的字节流
    
> 关于消息队列的 `C 语言`实现，请参考 [进程间通信-消息队列的 C 语言实现](https://blog.csdn.net/yang_yulei/article/details/19772649)。

* 共享内存
    * 多个进程可以直接读写同一块内存空间，是目前效率最高的 `IPC 机制`
    * 为了在多个进程间交换数据，`Linux 内核`专门留出了一块内存区域，允许由需要访问的进程将其映射到自己的私有地址空间。这也就意味着，进程可以直接读写这一块内存而不需要进行数据的拷贝，从而提升效率
    * 由于允许多个进程共享同一块内存区域，那么就需要依赖某种同步机制（信号量）来达到进程间的同步和互斥的目的
    
* 信号量：信号量是一个计数器，用于多进程对共享内存的访问，其目的是进程间的同步。为了获得共享资源，进程需要执行如下操作：
    * 创建一个信号量：调用者指定其初始值，对于二值信号来说，其值无非就是 0 或者 1
    * 等待一个信号量：该操作会测试信号量的值，如果小于 0，则阻塞
    * 挂出一个信号量：该操作将信号量的值加 1
    
* 套接字（Socket）：`Socket` 是一种基于 `客户端-服务端`模式的通信机制。

## Android 为什么选择 Binder 作为 IPC 机制

1. 从效率的角度来说，`管道`、`消息队列`和 `Socket` 的方式都需要对数据进行两次拷贝，而 `Binder` 只需要进行一次数据拷贝；

> 共享内存的方式无需进行数据拷贝，理论上来说是效率最为高效的。但是共享内存的方式需要协调进程间的同步问题，需要充分考虑访问临界资源的并发同步问题

2. 从稳定性的角度来说，`Binder` 是基于 `Client/Server` 架构的。`Client` 端和 `Server` 端相对独立，互不影响。
3. 从安全性的角度来说，基于 `Client/Server` 架构的模式，更容易实现权限控制策略。

## Binder 的实现原理

传统的 `IPC` 机制如`管道`、`Socket`等都是内核的组成部分，因此我们可以通过内核实现进程间通信。通过 `Linux` 的动态内核可加载模块的机制，可以将原本独立于内核之外的 `Binder` 动态的添加到内和空间，达到用户进程通过该内核模块（`Binder` 模块）作为桥梁进行数据交互的目的。

> `Android` 系统中，这个运行在内核空间，负责各个用户进程间数据交互的 `Binder` 内核模块称之为 `Binder 驱动`。

相较于传统 `IPC` 机制先将数据拷贝到内核缓冲区，再将数据从缓冲区拷贝出来的做法，`Binder` 机制采用了内存映射的方法。内存映射能够减少数据的拷贝次数，实现用户空间和内核空间的高效数据交互。两个空间对数据的各自修改能直接反映在映射的内存区域，从而被对方空间及时感知。

> 内存映射是指：将用户空间的一块内存区域映射到内核空间，映射关系建立后，用户对这块内存区域的修改可以直接反映到内核空间，而内核空间对该内存区域的修改也能直接反映到用户空间。

一次完整的 `Binder IPC` 的通信过程要经过如下步骤：

1. `Binder 驱动`在内核空间创建一个数据接收缓冲区；
2. 紧接着在内核空间开辟一块内核缓冲区，建立内核缓冲区和内核中数据接收缓冲区的映射关系，以及内核中数据接收缓冲区和数据接收进程的用户空间地址的映射关系；
3. 数据发送进程通过系统调用 `copy_from_user()` 将数据拷贝到内核中的内核缓冲区，由于内核缓冲区和数据接收进程的用户空间地址存在映射关系，因此，也就相当于把数据发送到了数据接收进程的用户空间。

下图形象的展示了以上过程：

![](https://pic4.zhimg.com/80/v2-cbd7d2befbed12d4c8896f236df96dbf_hd.jpg)

## Binder 整体架构

`Binder` 的整体架构图如下所示：

![](http://static.codeceo.com/images/2017/03/5222d04a068fc4082222c1d80c8aeb07.png)





## 参考文献 

[Android跨进程通信：图文详解 Binder机制 原理](https://blog.csdn.net/carson_ho/article/details/73560642)